/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, ReadTextFileCreateDevice)
#endif

NTSTATUS
ReadTextFileCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;

    PAGED_CODE();

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = DeviceGetContext(device);

        //
        // Initialize the context.
        //
        deviceContext->PrivateDeviceData = 0;

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_ReadTextFile,
            NULL // ReferenceString
            );

        if (NT_SUCCESS(status)) {
            //
            // Initialize the I/O Package and any Queues
            //
            status = ReadTextFileQueueInitialize(device);
        }

        WCHAR buffer[MAX_FILE_SIZE / sizeof(WCHAR)] = { 0 };
        size_t length = 0;

        status = ReadTextFile(buffer, FILE_NAME, &length);

        if (NT_SUCCESS(status)) {
            TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
                "%!FUNC! Length: %llu, Content: <%ws>", length, buffer);
        }
        else {
            TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "Failed to read file, status: %!STATUS!", status);
        }
    }

    return status;
}


NTSTATUS ReadTextFile(
    _Out_ PWCHAR OutBuffer,
    _In_ PWCHAR FileName,
    _Out_ size_t* Length
)
{
    NTSTATUS status;
    HANDLE fileHandle = NULL;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING uniFileName;
    LARGE_INTEGER byteOffset;
    PVOID buffer = NULL;

    // ファイル名のUNICODE_STRING作成
    RtlInitUnicodeString(&uniFileName, FileName);
    InitializeObjectAttributes(&objAttr, &uniFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

    // ファイルを開く
    status = ZwCreateFile(
        &fileHandle,
        GENERIC_READ,
        &objAttr,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
    );

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "Failed to open file: %wZ, status:  %!STATUS!", &uniFileName, status);
        return status;
    }

    // ファイルサイズを確認
    FILE_STANDARD_INFORMATION fileInfo;
    status = ZwQueryInformationFile(
        fileHandle,
        &ioStatusBlock,
        &fileInfo,
        sizeof(FILE_STANDARD_INFORMATION),
        FileStandardInformation
    );

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "Failed to query file information, status: %!STATUS!", status);
        ZwClose(fileHandle);
        return status;
    }

    if (fileInfo.EndOfFile.QuadPart > MAX_FILE_SIZE) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "File size exceeds maximum allowed size.");
        ZwClose(fileHandle);
        return STATUS_FILE_TOO_LARGE;
    }

    // 読み込み用のバッファ確保
    buffer = ExAllocatePool2(NonPagedPool, MAX_FILE_SIZE, 'txtR');
    if (!buffer) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "Failed to allocate buffer.");
        ZwClose(fileHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // ファイルを読み込む
    byteOffset.QuadPart = 0;
    status = ZwReadFile(
        fileHandle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        buffer,
        (ULONG)fileInfo.EndOfFile.QuadPart,
        &byteOffset,
        NULL
    );

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "Failed to read file, status:  %!STATUS!", status);
        ExFreePool(buffer);
        ZwClose(fileHandle);
        return status;
    }

    // 読み込んだデータをOutBufferにコピー
    RtlCopyMemory(OutBuffer, buffer, ioStatusBlock.Information);
    *Length = ioStatusBlock.Information / sizeof(WCHAR);

    // クリーンアップ
    ExFreePool(buffer);
    ZwClose(fileHandle);

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "File read successfully, bytes read: %llu", *Length);
    return STATUS_SUCCESS;
}
